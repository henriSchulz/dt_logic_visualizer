<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Logik-Visualizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
/*–– Layout ––*/
body{font-family:system-ui,sans-serif;margin:20px;}
h1{margin-top:0;} button,select{padding:4px 8px;font-size:1rem;cursor:pointer;}
table{border-collapse:collapse;margin:12px 0;}
th,td{border:1px solid #888;padding:4px 6px;text-align:center;}
th{background:#eee;}
.outCell,.kmap td{width:42px;height:42px;cursor:pointer;}
.on {background:#4caf50;color:#fff;font-weight:bold;}
.off{background:#fafafa;}
.dc {background:#ff9800;color:#fff;font-weight:bold;}
.hl {outline:2px solid #e91e63 !important;background:#ffebee !important;color:#000 !important;}
#views{display:flex;gap:32px;flex-wrap:wrap;}
#views>div{flex:1 1 280px;min-width:280px;}
.term{padding:2px 6px;margin:2px;border-radius:4px;cursor:pointer;display:inline-block}
.dnfTerm{background:#d0eaff;}   .cnfTerm{background:#ffe0e0;}
.dmfTerm{background:#b2ffb2;}   .kmfTerm{background:#ffd59e;}
</style>
</head>
<body>

<h1>Interaktiver Logik-Visualizer</h1>

<label>Presets :
    <select id="presetOp">
        <option value="custom">custom</option>
        <option value="and">AND</option>
        <option value="or">OR</option>
        <option value="xor" selected>XOR</option>
        <option value="nand">NAND</option>
        <option value="nor">NOR</option>
        <option value="xnor">XNOR</option>
    </select>
</label>

&nbsp;&nbsp;
Variablen 
<button id="minusBtn">−</button>
<span id="varCountLbl">3</span>
<button id="plusBtn">+</button>

<div id="views">
    <div>
        <h2>Wahrheitstabelle</h2>
        <div id="truthWrap"></div>
    </div>
    <div>
        <h2>Symmetriediagramm</h2>
        <div id="kmapWrap"></div>
    </div>
    <div>
        <h2>DNF/KNF & DMF/KMF</h2>
        <div id="exprWrap"></div>
    </div>
</div>

<script>
/*–––– Hilfsfunktionen ––––*/
const $  = id => document.getElementById(id);
const gray   = n => n ^ (n>>1);
const binStr = (n,b) => n.toString(2).padStart(b,'0');

/*–––– State ––––*/
let numVars=3;                      // 2…4
let truth  =[];                     // {bits:"0101",out:0|1|null}
let preset ='xor';
const letters=['A','B','C','D'];

/*–– DOM ––*/
const presetSel=$('presetOp'),minusBtn=$('minusBtn'),
      plusBtn=$('plusBtn'), varLbl=$('varCountLbl');

/*–––– Initial ––––*/
buildTruth(); applyPreset(); renderAll();

/*–––– UI ––––*/
minusBtn.onclick=()=>{if(numVars>2){numVars--; rebuild();}};
plusBtn.onclick =()=>{if(numVars<4){numVars++; rebuild();}};
presetSel.onchange=()=>{preset=presetSel.value;applyPreset();renderAll();};

/* Dbl-Click reset */
document.addEventListener('dblclick',e=>{
 if(!e.target.closest('#truthWrap')&&!e.target.closest('#kmapWrap')
    &&!e.target.closest('#exprWrap')){
   truth.forEach(r=>r.out=0); preset='custom';presetSel.value='custom';renderAll();
 }});

/*–––– Build / Rebuild ––––*/
function buildTruth(){
  truth=[]; for(let i=0;i<(1<<numVars);i++)
    truth.push({bits:binStr(i,numVars),out:0});
}
function rebuild(){buildTruth();applyPreset();renderAll();}
function applyPreset(){
 if(preset==='custom')return;
 truth.forEach(r=>r.out=calcPreset(r.bits,preset));
}
function calcPreset(bits,op){
 const ones=[...bits].filter(b=>b==='1').length;
 switch(op){
  case'and': return ones===bits.length?1:0;
  case'or' : return ones?1:0;
  case'xor': return ones&1;
  case'nand':return ones===bits.length?0:1;
  case'nor' :return ones?0:1;
  case'xnor':return (ones&1)?0:1;
 }
}

/*–––– Render ––––*/
function renderAll(){renderTruth();renderKMap();renderExpr();varLbl.textContent=numVars;}

/* Wahrheitstabelle */
function renderTruth(){
 let html='<table><tr>';
 for(let v=0;v<numVars;v++)html+=`<th>${letters[v]}</th>`;
 html+='<th>f</th></tr>';
 truth.forEach(r=>{
  const cls=r.out===1?'on':r.out===null?'dc':'off';
  const disp=r.out===null?'/':r.out;
  html+=`<tr data-bits="${r.bits}" class="tt-row">`;
  [...r.bits].forEach(b=>html+=`<td>${b}</td>`);
  html+=`<td class="outCell ${cls}" data-bits="${r.bits}">${disp}</td></tr>`;
 });
 html+='</table>';
 $('truthWrap').innerHTML=html;
 /* Click-Cycling */
 $('truthWrap').querySelectorAll('.outCell').forEach(td=>{
  td.onclick=e=>{
   const obj=truth.find(t=>t.bits===e.currentTarget.dataset.bits);
   obj.out=obj.out===0?1:obj.out===1?null:0;
   preset='custom';presetSel.value='custom';renderAll();
  };});
 addHoverEvents( $('truthWrap').querySelectorAll('.tt-row,.outCell') );
}

/* KV-Diagramm */
function renderKMap(){
 const rBits=Math.floor(numVars/2),cBits=numVars-rBits,
       rows=1<<rBits,cols=1<<cBits;
 let html='<table class="kmap"><tr><th></th>';
 for(let c=0;c<cols;c++)html+=`<th>${binStr(gray(c),cBits)}</th>`;
 html+='</tr>';
 for(let r=0;r<rows;r++){
  html+=`<tr><th>${binStr(gray(r),rBits)}</th>`;
  for(let c=0;c<cols;c++){
   const bits=binStr(gray(r),rBits)+binStr(gray(c),cBits);
   const obj=truth.find(t=>t.bits===bits);
   const cls=obj.out===1?'on':obj.out===null?'dc':'off';
   const disp=obj.out===null?'/':obj.out;
   html+=`<td class="${cls}" data-bits="${bits}">${disp}</td>`;
  }
  html+='</tr>';
 }
 html+='</table>';
 $('kmapWrap').innerHTML=html;
 $('kmapWrap').querySelectorAll('td[data-bits]').forEach(td=>{
  td.onclick=e=>{
   const obj=truth.find(t=>t.bits===e.currentTarget.dataset.bits);
   obj.out=obj.out===0?1:obj.out===1?null:0;
   preset='custom';presetSel.value='custom';renderAll();
  };});
 addHoverEvents( $('kmapWrap').querySelectorAll('td[data-bits]') );
}

/*–––– Expressionen ––––*/
function renderExpr(){
 const ones = truth.filter(r=>r.out===1).map(r=>parseInt(r.bits,2));
 const zeros= truth.filter(r=>r.out===0).map(r=>parseInt(r.bits,2));
 const dcs  = truth.filter(r=>r.out===null).map(r=>parseInt(r.bits,2));

 /* DNF / KNF (nicht minimiert) */
 const dnfRows=truth.filter(r=>r.out===1);
 const cnfRows=truth.filter(r=>r.out===0);

 const lit=(i,val,neg)=>neg?('¬'+letters[i]):letters[i];
 const termStr=(bits,type)=>[...bits].map((b,i)=>{
     if(b==='-')return '';
     return type==='dnf'
       ? (b==='1'?letters[i]:'¬'+letters[i])
       : (b==='0'?letters[i]:'¬'+letters[i]);
 }).filter(Boolean).join(type==='dnf'?'∧':'∨');

 /* DMF / KMF durch QM-Simplify */
 const dmf   = qmSimplify(numVars,ones,dcs);         // implicants als pattern '1-0-'
 const kmfPI = qmSimplify(numVars,zeros,dcs);        // für KMF über maxterms

 /* HTML */
 let html='<strong>DNF:</strong><br>';
 html+= dnfRows.length ? dnfRows.map(r=>`<span class="term dnfTerm" data-bits="${r.bits}">${termStr(r.bits,'dnf')}</span>`).join(' ∨ ')
                       :'0';

 html+='<hr><strong>KNF:</strong><br>';
 html+= cnfRows.length ? cnfRows.map(r=>`<span class="term cnfTerm" data-bits="${r.bits}">(${termStr(r.bits,'cnf')})</span>`).join(' ∧ ')
                       :'1';

 /* DMF */
 html+='<hr><strong>DMF (min):</strong><br>';
 if(dmf.length){
  html+=dmf.map(p=>{
      const cover=expandPattern(p).join('|');
      return `<span class="term dmfTerm" data-cover="${cover}">${termStr(p,'dnf')}</span>`;
   }).join(' ∨ ');
 }else html+='0';

 /* KMF */
 html+='<hr><strong>KMF (min):</strong><br>';
 if(kmfPI.length){
  html+= kmfPI.map(p=>{
     const cover=expandPattern(p).join('|');
     return `<span class="term kmfTerm" data-cover="${cover}">(${termStr(p,'cnf')})</span>`;
   }).join(' ∧ ');
 }else html+='1';

 $('exprWrap').innerHTML=html;

 /* Events */
 addHoverEvents( $('exprWrap').querySelectorAll('.term') );
 $('exprWrap').querySelectorAll('.term').forEach(el=>{
   el.onclick=e=>{
     const bits=e.currentTarget.dataset.bits;
     if(bits){                                 // Klick auf explizite Zeile
       const obj=truth.find(t=>t.bits===bits);
       obj.out=obj.out===0?1:obj.out===1?null:0;
       preset='custom';presetSel.value='custom';renderAll();
     }
   };
 });
}

/*–––– Quine-McCluskey ––––*/
function qmSimplify(vars,minterms,dcs=[]){
 const all=[...minterms,...dcs];
 if(!minterms.length)return [];                  // leer -> 0-Funktion
 /* 1. Prime-Implicants */
 let groups={},nextGroups={},checked=new Set(),primes=new Set();
 const oneCnt=x=>x.toString(2).replace(/0/g,'').length;
 all.forEach(v=>{
  const s=binStr(v,vars);(groups[oneCnt(v)]??=[]).push(s);
 });
 while(true){
  nextGroups={}; const used=new Set();
  const keys=Object.keys(groups).map(Number).sort((a,b)=>a-b);
  let combined=false;
  for(let i=0;i<keys.length-1;i++){
    const g1=groups[keys[i]]||[], g2=groups[keys[i+1]]||[];
    g1.forEach(a=>g2.forEach(b=>{
      const diffPos=diffBitPos(a,b);
      if(diffPos.length===1){
        combined=true;
        const merged=replaceAt(a,diffPos[0],'-');
        const cnt=merged.split('').filter(ch=>'1'===ch).length;
        (nextGroups[cnt]??=[]).push(merged);
        used.add(a); used.add(b);
      }
    }));
  }
  Object.values(groups).flat().forEach(s=>{if(!used.has(s))primes.add(s);});
  if(!combined)break;
  groups={};
  Object.entries(nextGroups).forEach(([k,arr])=>groups[k]=[...new Set(arr)]);
 }
 /* 2. Prime-chart */
 primes=[...primes];
 const covers=(pat,val)=>{
   const bs=binStr(val,vars);
   for(let i=0;i<vars;i++){
     if(pat[i]!=='-' && pat[i]!==bs[i])return false;
   }
   return true;
 };
 const chart=minterms.map(m=>primes.filter(p=>covers(p,m)));
 const essential=[]; let covered=new Set();
 chart.forEach((pis,idx)=>{
   if(pis.length===1){
     const pi=pis[0]; if(!essential.includes(pi)){
       essential.push(pi);
       minterms.filter(m=>covers(pi,m)).forEach(m=>covered.add(m));
     }
   }
 });
 /* 3. Greedy für Rest */
 let rest=minterms.filter(m=>!covered.has(m));
 let chosen=[...essential];
 while(rest.length){
   let bestPi=null,bestCnt=0;
   primes.forEach(p=>{
     const cnt=rest.filter(m=>covers(p,m)).length;
     if(cnt>bestCnt){bestCnt=cnt;bestPi=p;}
   });
   if(!bestPi)break;
   chosen.push(bestPi);
   rest=rest.filter(m=>!covers(bestPi,m));
 }
 return chosen;
}
/* Hilfs-Utilities */
function diffBitPos(a,b){
 const pos=[]; for(let i=0;i<a.length;i++)if(a[i]!==b[i])pos.push(i);
 return pos;
}
function replaceAt(str,idx,ch){return str.substring(0,idx)+ch+str.substring(idx+1);}
function expandPattern(pat){          // liefert alle konkreten Bitstrings für Highlight
 let res=[''];
 [...pat].forEach(ch=>{
  if(ch==='-') res=[...res.map(s=>s+'0'),...res.map(s=>s+'1')];
  else         res=res.map(s=>s+ch);
 });
 return res;
}

/*–––– Hover Sync ––––*/
function addHoverEvents(nodes){
 nodes.forEach(el=>{
  el.onmouseenter=()=>toggleHighlight(el,true);
  el.onmouseleave=()=>toggleHighlight(el,false);
 });
}
function toggleHighlight(el,flag){
 if(el.dataset.bits)   highlightBits([el.dataset.bits],flag);
 if(el.dataset.cover)  highlightBits(el.dataset.cover.split('|'),flag);
}
function highlightBits(arr,flag){
 arr.forEach(b=>document.querySelectorAll(`[data-bits="${b}"]`)
           .forEach(n=>n.classList.toggle('hl',flag)));
}
</script>
</body>
</html>
