<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Logik-Visualizer: TT, K-Map, DNF, KNF</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
/*–– Layout ––*/
body        {font-family:system-ui,sans-serif;margin:20px;}
h1          {margin-top:0;}
button,select{padding:4px 8px;font-size:1rem;cursor:pointer;}

/*–– Tabellen ––*/
table       {border-collapse:collapse;margin:12px 0;}
th,td       {border:1px solid #888;padding:4px 6px;text-align:center;}
th          {background:#eee;}
.outCell,
.kmap td    {width:42px;height:42px;cursor:pointer;}

/*–– Farben ––*/
.on   {background:#4caf50;color:#fff;font-weight:bold;}
.off  {background:#fafafa;}
.hl   {outline:2px solid #e91e63 !important;background:#ffebee !important;color:#000 !important;}

/*–– Flexbox für alle drei Ansichten ––*/
#views      {display:flex;gap:32px;flex-wrap:wrap;}

/*–– Term-Boxen ––*/
.term        {padding:2px 6px;margin:2px;border-radius:4px;cursor:pointer;display:inline-block}
.dnfTerm     {background:#d0eaff;}
.cnfTerm     {background:#ffe0e0;}
</style>
</head>
<body>

<h1>Interaktiver Logik-Visualizer</h1>

<label>Presets&nbsp;:
    <select id="presetOp">
        <option value="custom">custom</option>
        <option value="and">AND</option>
        <option value="or">OR</option>
        <option value="xor" selected>XOR</option>
        <option value="nand">NAND</option>
        <option value="nor">NOR</option>
        <option value="xnor">XNOR</option>
    </select>
</label>

&nbsp;&nbsp;

Variablen&nbsp;
<button id="minusBtn">−</button>
<span id="varCountLbl">3</span>
<button id="plusBtn">+</button>

<!-- Drei Ansichten nebeneinander -->
<div id="views">
    <div>
        <h2>Wahrheitstabelle</h2>
        <div id="truthWrap"></div>
    </div>

    <div>
        <h2>Symmetriediagramm</h2>
        <div id="kmapWrap"></div>
    </div>

    <div>
        <h2>DNF &amp; KNF</h2>
        <div id="exprWrap"></div>
    </div>
</div>

<script>
/*–––– Hilfsfunktionen ––––*/
const $      = id => document.getElementById(id);
const gray   = n => n ^ (n >> 1);                  // binary → Gray
const binStr = (n,bits) => n.toString(2).padStart(bits,'0');

/*–––– State ––––*/
let numVars = 3;                                   // 2 … 4
let truth   = [];                                  // [{bits:"010",out:0|1},…]
let preset  = 'xor';
const letters = ['A','B','C','D'];

/*–––– DOM-Referenzen ––––*/
const presetSel   = $('presetOp');
const minusBtn    = $('minusBtn');
const plusBtn     = $('plusBtn');
const varCountLbl = $('varCountLbl');

/*–––– Initialaufbau ––––*/
buildTruth();
applyPreset();
renderAll();
updateVarLabel();

/*–––– UI-Events ––––*/
minusBtn.onclick = () => { if (numVars > 2) { numVars--; rebuild(); } };
plusBtn.onclick  = () => { if (numVars < 4) { numVars++; rebuild(); } };

presetSel.onchange = () => {
    preset = presetSel.value;
    applyPreset();
    renderAll();
};

/* Doppelklick = Reset */
document.addEventListener('dblclick', e => {
    if (!e.target.closest('#truthWrap') &&
        !e.target.closest('#kmapWrap')  &&
        !e.target.closest('#exprWrap')) {
        truth.forEach(r => r.out = 0);
        presetSel.value = preset = 'custom';
        renderAll();
    }
});

/*–––– Build / Rebuild ––––*/
function buildTruth(){
    truth = [];
    for (let i = 0; i < (1 << numVars); i++){
        truth.push({bits: binStr(i,numVars), out: 0});
    }
}
function rebuild(){
    buildTruth();
    applyPreset();
    renderAll();
    updateVarLabel();
}
function updateVarLabel(){ varCountLbl.textContent = numVars; }

/*–––– Presets ––––*/
function calcPreset(bits, op){
    const ones = [...bits].filter(b => b === '1').length;
    switch(op){
        case 'and' : return ones === bits.length ? 1 : 0;
        case 'or'  : return ones ? 1 : 0;
        case 'xor' : return ones & 1;
        case 'nand': return ones === bits.length ? 0 : 1;
        case 'nor' : return ones ? 0 : 1;
        case 'xnor': return (ones & 1) ? 0 : 1;
        default    : return 0;
    }
}
function applyPreset(){
    if (preset === 'custom') return;
    truth.forEach(r => r.out = calcPreset(r.bits, preset));
}

/*–––– Render-Funktionen ––––*/
function renderAll(){
    renderTruthTable();
    renderKMap();
    renderExpressions();
}

/* Wahrheitstabelle */
function renderTruthTable(){
    let html = '<table><tr>';
    for (let v = 0; v < numVars; v++) html += `<th>${letters[v]}</th>`;
    html += '<th>f</th></tr>';

    truth.forEach(row => {
        const cls = row.out ? 'on' : 'off';
        html += `<tr data-bits="${row.bits}" class="tt-row">`;
        [...row.bits].forEach(b => html += `<td>${b}</td>`);
        html += `<td class="outCell ${cls}" data-bits="${row.bits}">${row.out}</td></tr>`;
    });
    html += '</table>';
    $('truthWrap').innerHTML = html;

    /* Klick → Toggle */
    $('truthWrap').querySelectorAll('.outCell').forEach(td => {
        td.onclick = e => {
            const bits = e.currentTarget.dataset.bits;
            const obj  = truth.find(t => t.bits === bits);
            obj.out ^= 1;
            presetSel.value = preset = 'custom';
            renderAll();
        };
    });

    addHoverEvents( $('truthWrap').querySelectorAll('.tt-row, .outCell') );
}

/* KV-Diagramm */
function renderKMap(){
    const rBits = Math.floor(numVars / 2);
    const cBits = numVars - rBits;
    const rows  = 1 << rBits, cols = 1 << cBits;

    let html = '<table class="kmap"><tr><th></th>';
    for (let c = 0; c < cols; c++) html += `<th>${binStr(gray(c), cBits)}</th>`;
    html += '</tr>';

    for (let r = 0; r < rows; r++){
        html += `<tr><th>${binStr(gray(r), rBits)}</th>`;
        for (let c = 0; c < cols; c++){
            const bits = binStr(gray(r), rBits) + binStr(gray(c), cBits);
            const obj  = truth.find(t => t.bits === bits);
            const cls  = obj.out ? 'on' : 'off';
            html += `<td class="${cls}" data-bits="${bits}">${obj.out}</td>`;
        }
        html += '</tr>';
    }
    html += '</table>';
    $('kmapWrap').innerHTML = html;

    /* Toggle */
    $('kmapWrap').querySelectorAll('td[data-bits]').forEach(td => {
        td.onclick = e => {
            const bits = e.currentTarget.dataset.bits;
            const obj  = truth.find(t => t.bits === bits);
            obj.out ^= 1;
            presetSel.value = preset = 'custom';
            renderAll();
        };
    });

    addHoverEvents( $('kmapWrap').querySelectorAll('td[data-bits]') );
}

/* DNF / KNF */
function renderExpressions(){
    const dnfRows = truth.filter(r => r.out);
    const cnfRows = truth.filter(r => !r.out);

    const termToString = (bits,type) => {
        let parts = [];
        for (let i = 0; i < numVars; i++){
            const b = bits[i];
            const lit = (type==='dnf')
                       ? (b==='1'?letters[i]:'¬'+letters[i])
                       : (b==='0'?letters[i]:'¬'+letters[i]);
            parts.push(lit);
        }
        return parts.join(type==='dnf' ? '∧' : '∨');
    };


    let html = '';

    /* DNF */
    html += '<strong>DNF:</strong><br>';
    if (dnfRows.length){
        html += dnfRows.map(r =>
                 `<span class="term dnfTerm" data-bits="${r.bits}">${termToString(r.bits,'dnf')}</span>`
              ).join(' ∨ ') ;
    } else {
        html += '0';
    }

    /* KNF */
    html += '<hr><strong>KNF:</strong><br>';
    if (cnfRows.length){
        html += cnfRows.map(r =>
                 `<span class="term cnfTerm" data-bits="${r.bits}">(${termToString(r.bits,'cnf')})</span>`
              ).join(' ∧ ');
    } else {
        html += '1';
    }

    $('exprWrap').innerHTML = html;

    /* Hover- & Klick-Events */
    addHoverEvents( $('exprWrap').querySelectorAll('.term') );

    // Klick auf Term toggelt Zeile im Truth-Table
    $('exprWrap').querySelectorAll('.term').forEach(el=>{
        el.onclick = e=>{
            const bits = e.currentTarget.dataset.bits;
            const obj  = truth.find(t => t.bits === bits);
            obj.out ^= 1;
            presetSel.value = preset = 'custom';
            renderAll();
        };
    });
}

/*Hover-Synchronisierung*/
function addHoverEvents(nodeList){
    nodeList.forEach(el => {
        const bits = el.dataset.bits;
        if (!bits) return;
        el.onmouseenter = () => highlight(bits, true);
        el.onmouseleave = () => highlight(bits, false);
    });
}
function highlight(bits, flag){
    document.querySelectorAll(`[data-bits="${bits}"]`)
            .forEach(el => el.classList.toggle('hl', flag));
}
</script>
</body>
</html>
